#### TCP/IP五层协议体系结构

**（1）应用层**

定义应用进程间通信和交互的规则。应用层交互的数据单元称为报文（message)

**（2）运输层**

为两台主机中应用进程之间的通信提供通用的数据传输服务。

运输船层向上层用户屏蔽了下面网络核心的细节，使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层进行交互的接口。

**（3）网络层**

为不同主机提供通信服务，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。

**（4）数据链路层**

将网络层交下来的数据报组装成帧，在两个相邻节点之间的链路上传送帧。

**（5）物理层**

为数据链路层提供物理连接，实现相邻计算机节点之间比特流的透明传送，屏蔽具体传输介质和物理设备的差异。

在物理层上传送数据的单元是比特。

#### OSI七层模型

OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。

OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰。

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

<img src="https://s4.51cto.com/images/20211016/1634320404920255.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="img" style="zoom:50%;" />

[](https://github.com/febobo/web-interview/issues/139)

#### OSI 参考模型与 TCP/IP 参考模型区别如下：

相同点：

- OSI 参考模型与 TCP/IP 参考模型都采用了层次结构
- 都能够提供面向连接和无连接两种通信服务机制

不同点：

- OSI 采用的七层模型； TCP/IP 是四层或五层结构

- OSI 参考模型虽然网络划分为七层，但实现起来较困难，一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。

- TCP/IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的

#### IP地址

**分类的IP地址**

网络号+主机号，这样的好处是：IP地址管理机构在分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号来转发分组，减少了路由表所占的存储空间以及查找路由表的时间。

<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220304125728437.png" alt="image-20220304125728437" style="zoom:67%;" />

A类地址可指派的网络号是126个(2^7 - 2)，IP地址中的全0表示"本网络"，网络号为127保留作为本地软件环回测试。

<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220304130137352.png" alt="image-20220304130137352" style="zoom:67%;" />

**划分子网**

从网络的主机号借用若干位作为子网号，采用三级IP地址：网络号+子网号+主机号。

**构成超网**

无分类编址CIDR。

消除了传统的A类、B类和C类地址以及划分子网的概念，采用无分类的两级编址：网络前缀+主机号。

CIDR把网络前缀都相同的连续的IP地址组成一个"CIDR地址块"。

#### IP地址与硬件地址

硬件地址是数据链路层和物理层使用的地址，是不可改变的，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。

#### 地址解析协议ARP

在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表。

ARP解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。

- 发送方H1是主机，要把IP数据报发送给同一个网络上的另一台主机H2，H1发送ARP请求分组，找到H2的硬件地址。
- 发送方H1是主机，要把IP数据报发送给另一个网络上的一台主机H3，H1发送ARP请求分组，找到同一网络上的路由器R1的硬件地址，剩下的工作有路由器R1完成。
- 发送方是路由器R1，要把IP数据报发送给同一个网络上的主机H3，R1发送ARP请求分组，找到H3的硬件地址。
- 发送方是路由器R1，要把IP数据报发送给另一个网络上的一台主机H4，R1发送ARP请求分组，找到另一个路由器R2的硬件地址。

#### IP数据报

<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220304130637673.png" alt="image-20220304130637673" style="zoom:67%;" />

- 版本：4位，指IP协议的版本
- 首部长度：4位
- 区分服务：8位
- 总长度：16位，指首部和数据之和的长度，单位为字节。
- 标识：16位，用来标志数据报，同一数据报的所有分片有相同的标识字段值。
- 标志：3位，最低位记为MF，MF=1表示后面“还有分片”的数据报，MF=0表示这是数据报片的最后一个。中间一位记为DF，表示不能分片，当DF=0时才允许分片。
- 片偏移：13位，分片在原分组中的相对位置，片偏移以8个字节位偏移单位。
- 生存时间：8位，TTL，数据报在网络中的寿命，指明数据报在网络中至多可经过多少个路由器。
- 协议：8位，指出此数据报携带的数据使用何种协议。
- 首部检验和：16位，只检验数据报的首部，不包括数据部分。

#### 网络层分片的原因与具体实现

IP协议中的分片算法主要解决不同物理网络最大传输单元（MTU）的不同造成的传输问题。

因为**在链路层中帧的大小通常都有限制**，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。

IP分片和完整IP报文差不多拥有相同的IP头，**16位标识**对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位标识号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而**13位片偏移**则记录了某IP分片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接收方就可以利用这些信息对IP数据进行重新组织。

详见：https://blog.csdn.net/gettogetto/article/details/72851734

#### 网际控制报文协议ICMP

ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。

`ICMP` 主要的功能包括：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。**

**ICMP差错报文**

- 终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。
- 时间超过：当路由器收到生存时间为0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。
- 参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。
- 改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。

**ICMP询问报文**

- 回送请求和回答：由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其相关状态。
- 时间戳请求和回答：请某台主机或路由器回答当前的日期和时间，用于时钟同步和时间测量。

PING是应用层直接使用网络层ICMP的一个例子，用来探测本机与网络中另一主机之间是否可达，它没有通过运输层的TCP或UDP。

ping是使用ICMP协议来进行工作的。

* 首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址一起交给IP层。
* 然后IP层就会构建一个IP数据报，并且在ARP映射表中查找目的IP对应的mac地址，将其交给数据链路层。
* 然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。

目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把数据帧中的IP数据报提取出来交给IP协议，IP协议检查后再将ICMP数据报提取出来交给ICMP协议处理。然后构建一个ICMP应答包，用相同的过程发送回去。

#### 分层次的路由选择协议

**内部网关协议IGP**，在一个自治系统内部使用的路由选择协议，RIP和OSPF协议。

**RIP**是一种分布式的基于距离向量的路由选择协议，

OSPF是开放最短路径优先协议，

**外部网关协议EGP**，自治系统之间的路由选择协议，BGP协议。

#### 在浏览器中输入URL后执行的全部过程（如www.baidu.com）

1. 首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；
2. 然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；
3. 接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）
4. 服务器对客户端发来的http请求进行处理，并返回响应；
5. 客户端接收到http响应，将结果渲染展示给用户。

#### http协议与TCP的区别与联系

联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。

区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。
建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。

#### http/1.0、http/1.1、http2.0的区别

HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。
**HTTP1.0** 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开TCP连接。最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive。

**HTTP 1.1** 支持长连接，默认进行长连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。

HTTP1.1还支持请求的流水线（Pipelining）处理，客户端不用等待上一次请求结果返回，就可以发出下一次请求（可以并行发送多个请求），但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

**HTTP2.0**相比之前版本，性能上有很大的提升，添加了以下特性：

- 多路复用：复用TCP连接，在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- 二进制分帧：将请求和响应数据分割为更小的帧，并且对它们采用二进制编码，而非 HTTP 1.x的文本格式，解析起来更高效。

帧是HTTP2.0数据通信的最小单位信息，每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件。

- 首部压缩：在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，既避免了重复header的传输，又减小了需要传输的大小。
- 服务器推送：服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

https://juejin.cn/post/6963931777962344455

https://vue3js.cn/interview/http/1.0_1.1_2.0.html#%E4%BA%8C%E3%80%81http1-1

#### http请求报文的方法

| 方法    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 请求读取由URL所标志的信息                                    |
| HEAD    | 请求读取由URL所标志的信息的首部                              |
| POST    | 向指定资源提交数据（例如提交表单或上传文件）                 |
| PUT     | 将数据发送到服务器来创建/更新资源                            |
| DELETE  | 删除指明的URL所标志的资源                                    |
| OPTION  | 请求一些选项的信息，一般也是用于客户端查看服务器的性能       |
| TRACE   | 用来进行环回测试的请求报文，回显服务器收到的请求，主要用于测试或诊断。 |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。     |

get和post的区别：

1. get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源
2. get可以保存为书签，可以用缓存来优化，而post不可以
3. get请求的数据会附在URL之后，而post方法提交的数据则放置在HTTP报文实体的主体里，所以post方法的安全性比get方法要高
4. 浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等
4. get产生一个TCP数据包，header和data一起发送，post产生两个TCP数据包，header先发送，服务器响应100后然后继续发送data
5. post可以传输二进制编码的信息，get的参数一般只支持ASCII

https://segmentfault.com/a/1190000040449935

安全：请求方法不会「破坏」服务器上的资源。

幂等：多次执行相同的操作，结果都是「相同」的。

**GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

**POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

PUT 与 POST 方法的区别在于，PUT 方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次 POST 方法可能会有副作用，比如将一个订单重复提交多次。

#### http的状态码 403 201等等是什么意思

详见 [HTTP状态码的含义](https://blog.csdn.net/u011630575/article/details/46636535)<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220304193012947.png" alt="image-20220304193012947" style="zoom: 67%;" />

常见的状态码有：

>* 100 继续 – 现在一切正常，继续
>* 102 处理 – 正在发生但尚未完成
>* 200 - 请求成功，一般用于GET与POST请求
>* 201 - 已创建，请求成功并且服务器创建了新的资源
>* 202 - 已接受，服务器已经接收请求，但尚未处理
>* 301 - 资源（网页等）被永久转移到其它URL
>* 302 - 资源（网页等）被临时移动到其它URL
>* 400 - 错误请求， 客户端请求的语法错误，服务器无法理解
>* 401 - 未授权，请求要求用户的身份认证
>* 403 - 禁止访问 
>* 404 - 请求的资源（网页等）不存在
>* 500 - 服务器内部错误
>* 503 - 由于超载或系统维护，服务器暂时无法处理客户端的请求

####  http和https的区别，由http升级为https需要做哪些操作

http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 **ssl 加密传输协议**
http 和 https 使用的是完全不同的连接方式，用的端口也不一样，**前者是 80 ，后者是 443**
http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。
https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用
https://www.cnblogs.com/wqhwe/p/5407468.html

#### https的具体实现，怎么确保安全性

**SSL是传输层的协议**，SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。

https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。

1. 建立TCP连接
1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接（客户端向服务端发送 HELLO 报文，这个报文中包含了客户端所支持的一些加密算法）
2. Web服务器收到客户端请求后，选定加密算法，并连同其网站的公钥传送一份给客户端，私钥自己保存。
3. 客户端对证书进行校验，提取服务器的公钥，并根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
4. Web服务器利用自己的私钥解密出会话密钥。
5. Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。

服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书

客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）

![img](https://pic002.cnblogs.com/images/2012/339704/2012071410212142.gif)

https://blog.csdn.net/qq_38291480/article/details/107843199

https://cloud.tencent.com/developer/article/1727994

#### HTTPS 解决了 HTTP 的哪些问题？

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
- **篡改风险**，比如强制入垃圾广告，视觉污染，用户眼容易瞎。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。

#### 对称密码和非对称密码体系

https://blog.csdn.net/qq_29689487/article/details/81634057

* 对称加密：加密和解密使用的密钥是同一个
  * 优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲
  * 常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES
* 非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密。如果用公钥对数据加密，那么只能用对应的私钥解密；如果用私钥对数据加密，只能用对应的公钥进行解密。
  * 优点：安全，不怕泄漏  缺点：速度慢
  * 常用算法：RSA，ECC，DSA

#### 消息摘要

对一份输入数据进行一个不可逆的 Hash计算，生成一个固定长度的 Hash 值，这个值就是这份数据的摘要（Digest），也称为指纹。

消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等，它们都有这些特点：

- 对于同一个摘要算法，无论输入的数据是什么，输出都是相同长度的值。 例如 MD5，无论数据有多大，输出总是128位的散列值。
- 摘要算法是单向的，只能根据原始数据计算出它的摘要值，但是不能根据摘要值反算出原始数据。
- 越优秀的摘要算法越难找到Hash碰撞。 虽然长内容生成短摘要是必定会产生碰撞的，但一个优秀的摘要算法很难主动构造出两条数据，使得他们的摘要值相同。
- 相比加密算法，摘要算法速度都相对较快。

使用场景：校验数据(消息)的完整性 、 数字签名

- 消息完整性：可以用于校验数据的完整性。 例如我们在下载文件时，数据源会提供一个文件的MD5。文件下载好之后，我们本地计算出文件的MD5，和数据源提供的MD5做对比，如果相同则文件是完整的。 但独立使用消息摘要时，无法确保数据没有被篡改，因为无法保证从数据源获取的MD5有没有被中途篡改。

- 安全访问认证：根据摘要算法不可逆性质，（就是无法从MD5值中恢复原数据）对账号登陆的密码进行MD5运算然后保存，这样可以保证除了用户之外，即使数据库管理人员都无法得知用户的密码。

- 数字签名：这是结合非对称加密算法和CA证书的一种使用场景。

  一般破解方法：字典法，就是将常用密码生成MD5值字典，然后反向查找达到破解目的，因此建议使用强密码

#### 介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）

* 消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等

* MD5算法介绍：
  MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）

1. MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。
2. 对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。
3. 接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。
4. 遍历所有分组后得到的四个变量即为结果。

详见：https://blog.csdn.net/weixin_39640298/article/details/84555814

* 为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。

* 加强安全性：加盐（加随机数）

#### 数字签名

如果用「公钥」对数据加密，用「私钥」去解密，这是「加密」； 反之用「私钥」对数据加密，用「公钥」去解密，这是「签名」。

数字签名：使用私钥对数据摘要进行签名，并附带和数据一起发送。

如何验证：先用相同的摘要算法计算原始信息的摘要值，再用公钥对签名解密，得到收到的摘要值，最后对比这两个摘要值判断是否相等。如果不相等说明数据不可信。

可以起到防篡改、防伪装、防否认的作用。

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e205231ce0304c57a92ffdec33a04487~tplv-k3u1fbpfcp-watermark.awebp" alt="22.webp" style="zoom:80%;" />

为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？

- 数据可能比较大，签名是使用非对称加密算法，比较耗时
- 防止第三方使用公钥解开签名后，拿到原始数据

数字签名方案的问题： 数据接收者如何获取正确的公钥呢？如果公钥本身都被篡改了，这个签名方案就不正确了。所以需要有某种方式确保公钥的正确性，这就是数字证书。

#### 数字证书

数字证书的作用： 解决如何安全分发公钥的问题。

权威CA使用CA的私钥对网站A的公钥等信息生成的消息摘要进行签名，将网站A的信息和签名打包形成数字证书。网站A将数字证书发给客户端，客户端用CA的公钥对数字证书里的签名进行解密，得到消息摘要1，与手动将网站的信息进行HASH得到的消息摘要2进行对比，如果一致就证明服务器发来的证书合法，没有被冒充，此时客户端就可以读取证书中的公钥，用于后续加密了。

https://juejin.cn/post/6984961336203542558

#### 加密通信演化

场景：Alice 和 Bob 进行通信，Eve 企图进行窃听。

https://segmentfault.com/a/1190000024523772

**明文传输**

存在问题：信息窃听、信息篡改、伪装通信方。

**对称加密**

方法：Alice 和 Bob 使用相同的密钥对信息进行加解密。
解决问题：信息窃听、信息篡改。
存在问题：秘钥泄露。

**非对称加密**

方法：Alice 和 Bob 使用对方的公钥加密信息、使用各自的私钥解密信息。
解决问题：秘钥泄露。
存在问题：伪装通信方、秘钥交换风险（公钥被截获并篡改）

**非对称加密 + 数字签名**

方法：Alice 和 Bob 使用各自的私钥对消息进行签名，使用对方的公钥进行消息签名验证，确保信息来源。
解决问题：伪装通信方。
存在问题：公钥交换风险（公钥被截获并篡改）

**非对称加密 + 数字签名 + 数字证书**

方法：由 CA 对 Alice 和 Bob 的公钥进行数字签名，生成数字证书。Alice 和 Bob 拿到对方的数字证书后，通过 CA 的公钥进行证书签名校验，以确保获得真实的对方公钥。
解决问题：公钥安全分发

#### TCP怎么保证可靠性？

**（校序重流拥）**

* **校验和**
  发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 

* **确认应答+序列号**
  TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 

* **超时重传**
  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 

* **流量控制**
  TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。
  接收方有即时窗口（滑动窗口），随ACK报文发送

* **拥塞控制**
  当网络拥塞时，减少数据的发送。

#### 传输控制协议TCP

- 面向连接的
- 点对点通信
- 提供可靠交付的服务，通过TCP连接传输的数据，无差错、不丢失、不重复，并且按序到达
- 提供全双工通信，允许通信双方的应用进程都能发送数据
- 面向字节流，TCP把应用进程交下来的数据仅仅看成是一连串的无结构的字节流。

#### TCP报文段

<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220226150902286.png" alt="image-20220226150902286" style="zoom:67%;" />

TCP报文段首部的前20个字节是固定的

- 序号（seq）：4字节，指本报文段所传送的数据的第一个字节的序号。
- 确认号（ack）：4字节，期望收到对方下一个报文段的数据的第一个字节的序号。若确认号为N，表明到序号N-1为止的所有数据都已正确收到。
- 数据偏移：4位，指出TCP报文段的首部长度。
- 保留：6位。
- 6个标志位
  - 紧急位 URG：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）。
  - 确认ACK，仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。
  - 推送 PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。
  - 复位 RST：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。
  - 同步 SYN：SYN = 1 表示这是一个连接请求或连接接受报文。
  - 终止 FIN：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。
- 窗口：2字节，窗口指的是发送本报文段的一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。窗口值作为接收端让发送端设置其发送窗口的依据。
- 检验和：2字节，检验和字段检验的范围包括首部和数据着两部分。
- 紧急指针：2字节，仅在URG=1时才有意义，指出本报文段中的紧急数据的字节数。
- 选项：长度可变，最长可达40字节。

#### TCP使用connect()建立连接时，会经历三次握手

<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220226140430101.png" alt="image-20220226140430101" style="zoom: 67%;" />



- 第一次握手：客户端给服务器发送连接请求报文，在这个报文中，SYN标志位为1，表示建立同步连接，seq（序号）字段为随机数x，发送之后进入SYN_SENT状态，等待服务器的确认；
- 第二次握手：服务器收到请求报文，给客户端发送ACK确认报文，该报文中标志位SYN和ACK都为1，小ack（确认后）字段为x+1，seq字段为随机数y，然后服务器进入SYN_RCVD状态；

- 第三次握手：客户端收到ACK报文，检测小ack字段是否为x+1，并给服务器回一个ACK报文，报文中标志位ACK为1，seq字段为x+1，小ack字段为y+1，客户端进入ESTABLISHED(已建立连接）状态。服务器收到ACK报文后检测小ack字段是否为y+1，然后进入ESTABLISHED状态。

#### 为什么采用三次握手，两次握手可以吗

1. 确认双方的收发能力，只有三次握手才能确认双方的发送和接收能力是否正常。
	○ 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常。
	○ 第二次握手（服务器响应 ACK+SYN 报文给客户端，客户端接收该报文）：客户端确认了自己发送、接收正常，对方发送、接收正常；不过此时服务器并不能确认客户端的接收能力是否正常。
	○ 第三次握手（客户端发送 ACK 报文给服务器）：这样服务器确认了自己发送、接收正常，对方发送、接收正常。
2. 序号可靠同步
	○ 如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序号。
3. 阻止重复历史连接的初始化
	○ 客户端由于某种原因发送了两个不同序号的 SYN 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 SYN 就会立刻建立连接，那么会造成网络异常。如果是三次握手，服务器需要回复 SYN+ACK 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 RST 报文，直到正常的 SYN 到达服务器后才正常建立连接。所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。

#### ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN为何要动态随机？

Initial Sequence Number，三次握手的其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道接下来接收数据的时候如何按序号组装数据。

ISN 随时间而变化，因此每个连接都将具有不同的 ISN。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

#### 什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

#### 三次握手过程中，可以携带数据吗？

第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手绝对不可以携带数据

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。

⭐ 简单的记忆就是，请求连接/接收 即 SYN = 1 的时候不能携带数据

而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。

#### 三次握手失败怎么办

如果服务器重复发送多次SYN+ACK报文之后仍然没有收到客户端的ACK应答，服务器会发送RTS报文段并主动关闭至closed，以防止syn洪泛攻击。

SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用半连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

#### TCP四次挥手

<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220226141500146.png" alt="image-20220226141500146" style="zoom:67%;" />

- 第一次挥手：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并停止再发送数据，主动关闭 TCP 连接。此时客户端处于 FIN_WAIT1 状态，等待服务端的确认。
- 第二次挥手：服务器端收到 FIN 包，发出确认包 ACK（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 CLOSE_WAIT 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 ACK 后，进入了 FIN_WAIT_2 状态。
- 第三次挥手：如果服务端也想断开连接了（没有要向客户端发出的数据），向客户端发送 FIN 包（seq=w，ack=u+1），服务器此时进入了 LAST_ACK 状态。
- 第四次挥手：客户端收到服务器的 FIN 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 TIME_WAIT 状态。注意此时 TCP 连接还没有释放，必须经过 2*MSL 后，才进入 CLOSED 状态（这样做的目的是确认服务器收到自己的ACK报文，如果服务器在规定时间内没有收到客户端发来的ACK报文，服务器会重新发送FIN报文给客户端，客户端再次收到FIN报文之后，就知道之前的ACK报文丢失了，然后再次发送ACK报文给服务器）。服务器端收到客户端的确认包 ACK 后就进入了 CLOSED 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。

#### 为什么建立连接握手三次，关闭连接时需要是四次呢？

在 TCP 握手的时候，接收端发送 SYN+ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中，所以减少了一次包的发送，三次完成握手。

对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。

#### TIME_WAIT的意义（为什么要等于2MSL）

TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。

MSL 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 FIN 的确认包 ACK 后，这个 ACK 包是有可能不可达的，服务器端如果收不到 ACK 的话需要重新发送 FIN 包。所以客户端发送 ACK 后需要留出 2MSL 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。

还有第 2 个理由，避免新旧连接混淆。在客户端发送完最后一个 ACK 报文段后，在经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。

#### 流量控制和拥塞控制

MSS：Maximum Segment Size，TCP一次传输发送的最大数据段长度。

RTT：Round-Trip Time，往返时延，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。

TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。

发送窗口在连接建立时由双方商定。但在通信的过程中，接收方可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)。

1. 接收端窗口 rwnd（也称为通知窗口）：接收端缓冲区大小，表示接收方的接收能力。接收端将此窗口值放在 TCP 报文首部中的窗口字段，传送给发送端。
2. 拥塞窗口cwnd (congestion window)：发送端缓冲区大小
3. 发送窗口swnd：发送窗口的上限值 = Min [rwnd, cwnd]
4. 当 rwnd < cwnd 时，是接收端的接收能力限制发送窗口的最大值，当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。

**流量控制**是让发送方的发送速率不要太快，让接收方来得及接收。

通过滑动窗口协议来实现流量控制。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。

考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送方将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致**死锁**。

解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。

另一个问题叫做**糊涂窗口综合征**，设想一种情况：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节，然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报是40字节长），接着，发送方又发来一个字节的数据（发送方发送的数据报是41字节长），接收方发回确认，仍将窗口设置为1个字节。这样进行下去，网络的效率很低。

解决这个问题，可以让接收方等待一段时间，使得或者接收缓存又足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间，然后接收方再发送确认报文，通知发送方当前的窗口大小。

**拥塞控制**是根据丢包情况估计网络的负载情况，调整发送速率，防止过多的数据注入到网络中，导致网络发生拥塞。

发送方维持一个拥塞窗口 cwnd \( congestion window \)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。

- 慢开始：在刚刚开始发送数据时，先以比较小的拥塞窗口（cwnd）进行发送，然后每收到一个对新报文段的确认，拥塞窗口加倍。
- 拥塞避免：当cwnd > ssthresh（慢开始门限）时，让拥塞窗口缓慢增大，每经过一个RTT加1.
- 快重传：让发送方尽早知道发生了个别报文段的丢失。当发送方连续收到3个重复确认时，立即重传丢失的报文段。
- 快恢复：发送方知道现在只是丢失了个别的报文段，调整门限值ssthresh = cwnd / 2，同时设置cwnd=ssthresh，并开始执行拥塞避免算法。

#### 用户数据报协议UDP

- UDP是无连接的，发送数据之前不需要建立连接
- 使用尽最大努力交付，不保证可靠交互
- 面向报文的，UDP对应用层交下来的报文，不进行合并或拆分，添加首部后就交付IP层
- 没有拥塞控制
- 支持一对一、一对多和多对多的交互通信
- 首部开销小，只有8字节

<img src="C:\Users\rbai\AppData\Roaming\Typora\typora-user-images\image-20220226155945224.png" alt="image-20220226155945224" style="zoom:67%;" />

- 长度：UDP用户数据报的长度，最小值是8（仅首部）
- 检验和：把首部和数据部分一起检验，检测数据在传输过程中是否发生变化。

#### 服务器出现大量close_wait的连接的原因以及解决方法

close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：

* 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法
* 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收

处理方法：

* 停止应用程序
* 修改程序里的bug

#### TCP/IP的粘包与避免介绍一下

因为TCP为了减少额外开销，采取的是**无边界的流式传输**，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。

导致TCP粘包的原因有三方面：

* 发送端等待缓冲区满才进行发送，造成粘包
* 接收方来不及接收缓冲区内的数据，造成粘包
* 由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送

避免粘包的措施：

* 通过编程，**强制使TCP发生数据传送**，不必等到缓冲区满
* 优化接收方接收数据的过程，使其来得及接收数据包，包括**提高接收进程优先级**等
* 设置固定长度的报文或者**设置报文头部指示报文的长度**。

UDP会不会产生粘包问题呢？
TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。

UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

#### （36） 说一下TCP的封包和拆包

因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。

* 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分**。包头是一个固定长度的结构体，里面包含该数据包的总长度。**
* 拆包：接收方在接收到报文后**提取包头中的长度信息进行截取**。

#### DNS（域名系统）的工作过程和原理

DNS解析有两种方式：递归查询和迭代查询

* 递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。
* 迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果

1. 浏览器搜索**自己的DNS缓存**
2. 若没有，则搜索**操作系统中的DNS缓存和hosts文件**
3. 若没有，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向**根域名服务器、顶级域名服务器、权限域名服务器**发起查询请求，最终返回IP地址给本地域名服务器
4. 本地域名服务器将得到的IP地址返回给**操作系统**，同时自己也**将IP地址缓存起来**
5. 操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来
6. 浏览器得到域名对应的IP地址

#### Cookie和Session的区别

Cookie是服务器发送到浏览器的一小块数据，浏览器会对Cookie进行存储，在浏览器下次向同一服务器发起请求时，会与请求一起发送到服务器。

Session存储特定用户会话所需的属性及配置信息，

- **作用范围不同**，Cookie 保存在客户端，Session 保存在服务器端。
- **有效期不同**，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
- **隐私策略不同**，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- **存储大小不同**， 单个 Cookie 保存的数据不能超过 4K；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，并将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器会将服务器返回的 SessionID 信息存入Cookie 中。当用户再访问服务器时，会将Cookie和请求一起发送给服务器，服务器根据 SessionID 查找对应的 Session 信息来验证用户。

#### MTU和MSS分别是什么？

MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。

MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。

#### 什么时候用长连接，短连接？

1、需要**频繁交互**的场景使用长连接，如即时通信工具（微信/QQ，QQ也有UDP），相反则使用短连接，比如普通的web网站，只有当浏览器发起请求时才会建立连接，服务器返回相应后，连接立即断开。

2、**维持长连接**会有一定的系统开销，用户量少不容易看出系统瓶颈，一旦用户量上去了，就很有可能把服务器资源（内存/CPU/网卡）耗尽，所以使用需谨慎。

























