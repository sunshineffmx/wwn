### B树

B树也称B-树,它是一颗多路平衡查找树，一棵m阶的B树定义为：

- 每个节点最多有m-1个**关键字**（可以存有的键值对）。
- 根节点最少可以只有1个**关键字**。
- 非根节点至少有m/2个**关键字**。
- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
- 每个节点都存有索引和数据，也就是对应的key和value。

<img src="https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232634472-395289491.png" alt="clip_image002" style="zoom:67%;" />

**插入操作：**

1）根据要插入的key的值，找到叶子结点并插入。

2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。

3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

**删除操作：**

1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步

2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。

3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。

否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。

有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。

https://www.cnblogs.com/nullzx/p/8729425.html

https://segmentfault.com/a/1190000020416577

### B+树

与B树相同点：

- 根节点至少一个元素
- 非根节点元素范围：m/2 <= k <= m-1

不同点：

- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- 父节点存有右孩子的第一个元素的索引。

插入操作：

当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。

### LSM-Tree

**特点**

- 通过将大量的随机写转换为顺序写，从而极大地提升了数据写入的性能，虽然与此同时牺牲了部分读的性能。
- 只适合存储 key 值有序且写入大于读取的数据，或者读取操作通常是 key 值连续的数据。

#### 存储模型

**WAL**

当插入一条数据时，数据先顺序写入 WAL 文件中，之后插入到内存中的 MemTable 中。这样就保证了数据的持久化，不会丢失数据，并且写WAL是顺序写（append方式），速度很快。

**MemTable**

在内存中的数据结构，通常用 SkipList 来实现。MemTable 提供了KV数据的写入、删除以及读取的操作接口。其内部将 键值对按照 key 值有序存储。

**Immutable MemTable**

在内存中只读的 MemTable，由于内存是有限的，通常我们会设置一个阀值，当 MemTable 占用的内存达到阀值后就自动转换为 Immutable MemTable。它是将MemTable转变为SSTable的一种中间状态，目的是为了在转存过程中不阻塞写操作，写操作可以由新的MemTable处理，而不用因为锁住MemTable而等待。

**SSTable**

数据在磁盘上的有序存储，其内部数据是根据 key 从小到大排列的。如果SSTable比较大的时候，还可以根据键的值建立一个索引来加速SSTable的查询。

![SSTable.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/11/16b47414ad483b3a~tplv-t2oaga2asx-watermark.awebp)

SSTable 通常采用的分级的结构，例如 LevelDB 中就是如此。MemTable 中的数据达到指定阀值后会在 Level 0 层创建一个新的 SSTable。当某个 Level 下的文件数超过一定值后，就会将这个 Level 下的一个 SSTable 文件和更高一级的 SSTable 文件合并，由于 SSTable 中的 k-v 数据都是有序的，相当于是一个多路归并排序，所以合并操作相当快速，最终生成一个新的 SSTable 文件，将旧的文件删除，这样就完成了一次合并过程。

#### 常用操作

**写入**

在 WAL 文件中顺序写入当次操作的内容，成功之后将该 k-v 数据写入 MemTable 中即可。

**更新**

更新操作其实并不真正存在，和写入一个 k-v 数据没有什么不同，只是在读取的时候，会从 Level0 层的 SSTable 文件开始查找数据，数据在低层的 SSTable 文件中必然比高层的文件中要新，所以总能读取到最新的那条数据。也就是说此时在整个 LSM Tree 中可能会同时存在多个 key 值相同的数据，只有在之后合并 SSTable 文件的时候，才会将旧的值删除。

**删除**

删除一条记录的操作比较特殊，并不立即将数据从文件中删除，而是记录下对这个 key 的删除操作标记，同插入操作相同，插入操作插入的是 k-v 值，而删除操作插入的是 k-del 标记，只有当合并 SSTable 文件时才会真正的删除。

**读取**

读操作需要依次读取memtable、immutable memtable、SSTable0、SSTable1......。一旦匹配到了要读取的数据，那么一定是最新的数据，只要返回该数据即可。

在每一层的 SSTable 文件的 key 值范围是不重复的，所以只需要查找其中一个 SSTable 文件即可确定指定 key 的数据是否存在于这一层中。Level 0 层比较特殊，因为数据是 Immutable MemTable 直接写入此层的，所以 Level 0 层的 SSTable 文件的 key 值范围可能存在重复，查找数据时有可能需要查找多个文件。

**Compaction**

当数据不断从 Immutable Memtable 序列化到磁盘上的 SSTable 文件中时，SSTable 文件的数量就不断增加，而且其中可能有很多更新和删除操作并不立即对文件进行操作，而只是存储一个操作记录，这就造成了整个 LSM Tree 中可能有大量相同 key 值的数据，占据了磁盘空间。为了节省磁盘空间占用，控制 SSTable 文件数量，需要将多个 SSTable 文件进行合并，生成一个新的 SSTable 文件。

合并策略：

- Leveling Merge Policy：
  - 每个level仅有1个组件，但L1的组件大小是L0的N倍，当L0满时，L0和L1合并，合并到L1中；
  - 由于组件较少，查询性能较高，LevelDB和RocksDB使用该策略；
- Tiering Merge Policy:
  - 每个level有N个组件，合并后生成level+1的一个新组件；
  - 由于可以降低合并的频率，写入性能较高；

在LevelDB中，Compaction大致分为以下两个模块：

- Minor Compaction，指的是 immutable memtable持久化为 SSTable。

- Major Compaction，当每层的磁盘上的SSTable超过一定的大小或者个数，合并SSTable到下一层中。

**优化读取**

- LevelDB 中的 Mainfest 文件，这个文件记录了 SSTable 文件的一些关键信息，例如 Level 层数，文件名，最小 key 值，最大 key 值等，这个文件通常不会太大，可以放入内存中，可以帮助快速定位到要查询的 SSTable 文件，避免频繁读取。
- SSTable的索引块：每个SSTable文件中加入索引块，索引块中记录key及其offset，key按顺序排列。
  查找时，先在索引中二分查找key和offset，然后再到SSTable中读取key-value。
- 布隆解析器(Bloom filter)，判定一个SSTable是否包含特定的建，以减少访问磁盘次数。


https://kejiang.co/2022/02/26/lsm-tree/









































